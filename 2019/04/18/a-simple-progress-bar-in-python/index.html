<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>A Simple Progress Bar in Python</title><link rel=stylesheet href=/css/style.css></head><body><header>===================<br>== <a href=mayn.es>Nathan's Blog</a> ==<br>===================<div style=float:right>infrequent posts about things I am working on</div><br><p><nav><a href=/><b>Start</b></a>.
<a href=/mayn.es/post/><b>Posts</b></a>.
<a href=/mayn.es/categories/><b>Categories</b></a>.
<a href=/mayn.es/tags/><b>Tags</b></a>.</nav></p></header><main><article><h1>A Simple Progress Bar in Python</h1><b><time>18.04.2019 18:33</time></b>
<a href=/mayn.es/tags/function>function</a>
<a href=/mayn.es/tags/python>python</a>
<a href=/mayn.es/tags/requests>requests</a><div><p>Recently, I have been working with the Requests library in Python. I wrote a simple function to pull down a file that took more than a minute to download. While waiting for the download to complete I realized it would be nice to have some insight into the download’s progress. A quick search on StackOverflow led to an excellent example. Below is a simple way to display a progress bar while downloading a file.</p><h2 id=what8217s-going-on>What’s going on?</h2><p>requests.get() takes a URL and creates an HTTP request. The stream=True flag is an optional argument that can be submitted to the Request class. It lets the Request know that the content should be downloaded in chunks instead of attempted to be pulled all at once.</p><p>The response headers are then searched for the ‘Content-Length’ attribute. We use the ‘Content-Length’ value to calculate how much is downloaded and what is left to download. The values are then stored in variables and updated as the chunks are processed.</p><p>The final piece to point out in this little function is the iter_content() method. iter_content():</p><p>This helps handle larger files and gives us a way to track progress. As chunks are processed, variables can be updated. If you do not need or want to roll your own, check out the <code>&lt;a href="https://github.com/tqdm/tqdm">tdqm&lt;/a></code> <a href=https://github.com/tqdm/tqdm>library</a>.</p></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=mayn.es/post/2021-04-03-dynamically-set-schemas-sqlalchemy/>Dynamically Set ORM Schemas via Sqlalchemy</a></li><li><a href=mayn.es/2020/11/29/a-primer-on-data-normalization/>A Primer on Data Normalization</a></li><li><a href=mayn.es/2020/11/27/deals-deals-deals/>Deals, Deals, Deals</a></li><li><a href=mayn.es/2020/08/28/let-pycharm-use-wsls-git-executable/>Let Pycharm Use WSL&amp;#8217;s Git Executable</a></li><li><a href=mayn.es/2020/08/01/speed-up-your-rest-workflows-with-asyncio/>Speed Up Your REST Workflows with asyncio</a></li></ul></div></div></aside><footer><p>&copy; 2021 <a href=mayn.es><b>Nathan's Blog</b></a>.
<a href=https://github.com/nmaynes><b>Github</b></a>.
<a href=https://twitter.com/@nmaynes><b>Twitter</b></a>.</p></footer></body></html>